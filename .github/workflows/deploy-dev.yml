name: Deploy to Dev Environment

on:
  push:
    branches: [staging]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  NODE_VERSION: "20"

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"
          cache-dependency-path: "src/backend/pnpm-lock.yaml"

      - name: Install dependencies
        working-directory: ./src/backend
        run: pnpm install --frozen-lockfile

      - name: Run tests
        working-directory: ./src/backend
        run: pnpm test

      - name: Build application
        working-directory: ./src/backend
        run: pnpm build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Package Lambda function
        working-directory: ./src/backend
        run: |
          set -euo pipefail
          rm -rf lambda-package lambda-deployment.zip
          mkdir -p lambda-package

          # Build is already done in previous step
          cp -r dist/* lambda-package/

          # Production deps only, pruned
          pnpm install --frozen-lockfile
          pnpm prune --prod
          cp -r node_modules lambda-package/
          cp package.json lambda-package/

          # Zip
          cd lambda-package
          zip -rq ../lambda-deployment.zip . -x "*.git*" "*.DS_Store*"
          cd ..

          du -sh lambda-package || true
          ls -lh lambda-deployment.zip || true

          # ✅ Base64-encoded SHA256 hash (what Terraform expects)
          LAMBDA_HASH=$(openssl dgst -sha256 -binary lambda-deployment.zip | base64)
          echo "LAMBDA_HASH=$LAMBDA_HASH" >> "$GITHUB_ENV"

      - name: Who am I?
        run: |
          aws sts get-caller-identity
          aws s3 ls s3://portfolio-dev-deployments/ || true

      - name: Upload to S3 with timestamp
        working-directory: ./src/backend
        run: |
          set -euo pipefail
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          S3_KEY="lambda/portfolio-dev-api-${TIMESTAMP}.zip"

          echo "🚀 Uploading to S3: ${S3_KEY}"
          echo "📊 File size: $(ls -lh lambda-deployment.zip | awk '{print $5}')"

          SIZE=$(stat --format=%s lambda-deployment.zip 2>/dev/null || stat -f%z lambda-deployment.zip)
          aws s3 cp lambda-deployment.zip "s3://portfolio-dev-deployments/${S3_KEY}" \
            --region us-east-1 \
            --no-progress \
            --only-show-errors \
            --expected-size "$SIZE" \
            --cli-read-timeout 60 --cli-connect-timeout 15

          echo "LAMBDA_S3_KEY=${S3_KEY}" >> "$GITHUB_ENV"
          echo "✅ Upload completed: ${S3_KEY}"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Create terraform.tfvars file (base64, exact)
        working-directory: ./src/infra/environments/dev
        shell: bash
        run: |
          set -euo pipefail
          # Decode the entire tfvars from a base64 secret (no YAML/shell parsing issues)
          printf '%s' "${{ secrets.TFVARS_CONTENT_DEV_B64 }}" | base64 -d > terraform.tfvars

          # Normalize CRLF -> LF just in case
          tr -d '\r' < terraform.tfvars > tf.tmp && mv tf.tmp terraform.tfvars

          # Quick sanity: show size (not contents)
          echo "Wrote terraform.tfvars ($(wc -c < terraform.tfvars) bytes)"

      - name: Terraform Init
        working-directory: ./src/infra/environments/dev
        run: terraform init

      - name: Import existing buckets (idempotent)
        working-directory: ./src/infra/environments/dev
        run: |
          set -euo pipefail

          imp() {
            addr="$1"; id="$2"
            if terraform state show "$addr" >/dev/null 2>&1; then
              echo "State already has $addr"
            else
              echo "Importing $addr -> $id"
              terraform import "$addr" "$id" || true
            fi
          }

          # Buckets exist; import the bucket resources only.
          imp 'module.s3_deployments.aws_s3_bucket.this' portfolio-dev-deployments
          imp 'module.s3_media.aws_s3_bucket.this'       portfolio-dev-media
          imp 'module.s3_frontend.aws_s3_bucket.this'    dev.petertconti.com

      - name: Terraform Plan with new Lambda
        working-directory: ./src/infra/environments/dev
        run: |
          terraform plan \
            -var="lambda_s3_key=${{ env.LAMBDA_S3_KEY }}" \
            -var="lambda_source_code_hash=${{ env.LAMBDA_HASH }}" \
            -var-file=terraform.tfvars \
            -out=tfplan

          echo "📋 Terraform will update Lambda with new code from: ${{ env.LAMBDA_S3_KEY }}"

      - name: Terraform Apply
        working-directory: ./src/infra/environments/dev
        run: |
          terraform apply -auto-approve tfplan
          echo "✅ Terraform apply completed - Lambda updated through IaC!"

      - name: Test API endpoint
        run: |
          echo "⏳ Waiting for Lambda to warm up..."
          sleep 30

          echo "🧪 Testing API endpoints..."
          curl -f https://dev.petertconti.com/api/cats || echo "❌ Cats API test failed"
          curl -f https://dev.petertconti.com/api/auth || echo "❌ Auth API test failed"

      - name: Deployment Summary
        run: |
          echo "🚀 Deployment completed successfully!"
          echo "📦 Lambda package: ${{ env.LAMBDA_S3_KEY }}"
          echo "📍 API URL: https://dev.petertconti.com/api"
          echo "🐱 Cats endpoint: https://dev.petertconti.com/api/cats"
          echo "🔐 Auth endpoint: https://dev.petertconti.com/api/auth"
          echo "✅ All infrastructure managed by Terraform!"
