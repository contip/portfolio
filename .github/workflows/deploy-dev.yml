name: Deploy to Dev Environment

on:
  push:
    branches: [staging]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  NODE_VERSION: "20"
  ECR_REPOSITORY: portfolio-dev-lambda

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"
          cache-dependency-path: "**/pnpm-lock.yaml"

      # Backend build
      - name: Install backend dependencies
        working-directory: ./src/backend
        run: pnpm install --frozen-lockfile

      - name: Run backend tests
        working-directory: ./src/backend
        run: pnpm test

      - name: Build backend
        working-directory: ./src/backend
        run: pnpm build

      # Frontend build
      - name: Install frontend dependencies
        working-directory: ./src/frontend
        run: pnpm install --frozen-lockfile

      - name: Build frontend
        working-directory: ./src/frontend
        run: pnpm build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Build and push Docker image
        working-directory: ./src/backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail

          # Build ARM64 image without provenance
          echo "ðŸ”¨ Building Docker image for ARM64..."
          docker buildx build \
            --platform linux/arm64 \
            --provenance=false \
            -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG} \
            -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest \
            --push \
            .

          echo "âœ… Image pushed to ECR:"
          echo "   ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
          echo "   ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"

          # Store image URI for Terraform
          echo "LAMBDA_IMAGE_URI=${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" >> "$GITHUB_ENV"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Create terraform.tfvars file
        working-directory: ./src/infra/environments/dev
        shell: bash
        run: |
          set -euo pipefail
          # Decode the entire tfvars from a base64 secret
          printf '%s' "${{ secrets.TFVARS_CONTENT_DEV_B64 }}" | base64 -d > terraform.tfvars

          # Normalize CRLF -> LF just in case
          tr -d '\r' < terraform.tfvars > tf.tmp && mv tf.tmp terraform.tfvars

          echo "Wrote terraform.tfvars ($(wc -c < terraform.tfvars) bytes)"

      - name: Terraform Init
        working-directory: ./src/infra/environments/dev
        run: terraform init

      - name: Terraform Plan with new container
        working-directory: ./src/infra/environments/dev
        run: |
          terraform plan \
            -var="lambda_image_uri=${{ env.LAMBDA_IMAGE_URI }}" \
            -var-file=terraform.tfvars \
            -out=tfplan

          echo "ðŸ“‹ Terraform will update Lambda with new container image:"
          echo "   ${{ env.LAMBDA_IMAGE_URI }}"

      - name: Terraform Apply
        working-directory: ./src/infra/environments/dev
        run: |
          terraform apply -auto-approve tfplan
          echo "âœ… Terraform apply completed - Lambda updated with new container!"

      - name: Deploy frontend to S3
        run: |
          echo "ðŸš€ Deploying frontend to S3..."
          aws s3 sync ./src/frontend/dist s3://dev.petertconti.com/ \
            --delete \
            --cache-control "public, max-age=3600" \
            --exclude "*.html" \
            --no-cli-pager

          # HTML files with shorter cache
          aws s3 sync ./src/frontend/dist s3://dev.petertconti.com/ \
            --delete \
            --cache-control "public, max-age=300" \
            --exclude "*" \
            --include "*.html" \
            --content-type "text/html" \
            --no-cli-pager

          echo "âœ… Frontend deployed to S3!"

      - name: Invalidate CloudFront cache
        run: |
          echo "ðŸ”„ Invalidating CloudFront cache..."
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?contains(Aliases.Items, 'dev.petertconti.com')].Id" \
            --output text)

          if [ -n "$DISTRIBUTION_ID" ]; then
            aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/*" \
              --no-cli-pager
            echo "âœ… CloudFront cache invalidated for distribution $DISTRIBUTION_ID"
          else
            echo "âš ï¸ No CloudFront distribution found for dev.petertconti.com"
          fi

      - name: Wait for Lambda to become active
        run: |
          aws lambda wait function-updated \
            --function-name portfolio-dev-api \
            --region ${{ env.AWS_REGION }} || true

      - name: Test API endpoint
        run: |
          echo "â³ Waiting for Lambda cold start..."
          sleep 30

          echo "ðŸ§ª Testing API endpoints..."

          # Test cats endpoint
          echo "Testing /api/cats..."
          response=$(curl -s -o /dev/null -w "%{http_code}" https://dev.petertconti.com/api/cats)
          if [ "$response" -eq 200 ]; then
            echo "âœ… Cats API test passed (HTTP $response)"
          else
            echo "âš ï¸ Cats API returned HTTP $response"
          fi

          # Test auth endpoint
          echo "Testing /api/auth..."
          response=$(curl -s -o /dev/null -w "%{http_code}" https://dev.petertconti.com/api/auth)
          if [ "$response" -eq 200 ] || [ "$response" -eq 401 ]; then
            echo "âœ… Auth API test passed (HTTP $response)"
          else
            echo "âš ï¸ Auth API returned HTTP $response"
          fi

      - name: Deployment Summary
        run: |
          echo "ðŸš€ Deployment completed successfully!"
          echo "ðŸ“¦ Backend container: ${{ env.LAMBDA_IMAGE_URI }}"
          echo "ðŸŒ Frontend URL: https://dev.petertconti.com"
          echo "ðŸ“ API URL: https://dev.petertconti.com/api"
          echo "ðŸ± Cats endpoint: https://dev.petertconti.com/api/cats"
          echo "ðŸ” Auth endpoint: https://dev.petertconti.com/api/auth/google"
          echo "âœ… Full stack deployed: Vue frontend (S3) + NestJS backend (Lambda) + CloudFront CDN!"
