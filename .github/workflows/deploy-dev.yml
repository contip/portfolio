name: Deploy to Dev Environment

on:
  push:
    branches: [staging]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  NODE_VERSION: "20"
  ECR_REPOSITORY: portfolio-dev-lambda

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"
          cache-dependency-path: "src/backend/pnpm-lock.yaml"

      - name: Install dependencies
        working-directory: ./src/backend
        run: pnpm install --frozen-lockfile

      - name: Run tests
        working-directory: ./src/backend
        run: pnpm test

      - name: Build application
        working-directory: ./src/backend
        run: pnpm build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Build and push Docker image
        working-directory: ./src/backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail

          # Build ARM64 image without provenance
          echo "ðŸ”¨ Building Docker image for ARM64..."
          docker buildx build \
            --platform linux/arm64 \
            --provenance=false \
            -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG} \
            -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest \
            --push \
            .

          echo "âœ… Image pushed to ECR:"
          echo "   ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
          echo "   ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"

          # Store image URI for Terraform
          echo "LAMBDA_IMAGE_URI=${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" >> "$GITHUB_ENV"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Create terraform.tfvars file
        working-directory: ./src/infra/environments/dev
        shell: bash
        run: |
          set -euo pipefail
          # Decode the entire tfvars from a base64 secret
          printf '%s' "${{ secrets.TFVARS_CONTENT_DEV_B64 }}" | base64 -d > terraform.tfvars

          # Normalize CRLF -> LF just in case
          tr -d '\r' < terraform.tfvars > tf.tmp && mv tf.tmp terraform.tfvars

          echo "Wrote terraform.tfvars ($(wc -c < terraform.tfvars) bytes)"

      - name: Terraform Init
        working-directory: ./src/infra/environments/dev
        run: terraform init

      - name: Terraform Plan with new container
        working-directory: ./src/infra/environments/dev
        run: |
          terraform plan \
            -var="lambda_image_uri=${{ env.LAMBDA_IMAGE_URI }}" \
            -var-file=terraform.tfvars \
            -out=tfplan

          echo "ðŸ“‹ Terraform will update Lambda with new container image:"
          echo "   ${{ env.LAMBDA_IMAGE_URI }}"

      - name: Terraform Apply
        working-directory: ./src/infra/environments/dev
        run: |
          terraform apply -auto-approve tfplan
          echo "âœ… Terraform apply completed - Lambda updated with new container!"

      - name: Force Lambda update
        run: |
          echo "ðŸ”„ Forcing Lambda function update..."
          aws lambda update-function-code \
            --function-name portfolio-dev-api \
            --image-uri ${{ env.LAMBDA_IMAGE_URI }} \
            --region ${{ env.AWS_REGION }} \
            --no-cli-pager || echo "Note: Lambda update may take a moment to propagate"

          echo "â³ Waiting for Lambda to stabilize..."
          sleep 10

          aws lambda wait function-updated \
            --function-name portfolio-dev-api \
            --region ${{ env.AWS_REGION }} || echo "Lambda is updating..."

      - name: Test API endpoint
        run: |
          echo "â³ Waiting for Lambda cold start..."
          sleep 30

          echo "ðŸ§ª Testing API endpoints..."

          # Test cats endpoint
          echo "Testing /api/cats..."
          response=$(curl -s -o /dev/null -w "%{http_code}" https://dev.petertconti.com/api/cats)
          if [ "$response" -eq 200 ]; then
            echo "âœ… Cats API test passed (HTTP $response)"
          else
            echo "âš ï¸ Cats API returned HTTP $response"
          fi

          # Test auth endpoint
          echo "Testing /api/auth..."
          response=$(curl -s -o /dev/null -w "%{http_code}" https://dev.petertconti.com/api/auth)
          if [ "$response" -eq 200 ] || [ "$response" -eq 401 ]; then
            echo "âœ… Auth API test passed (HTTP $response)"
          else
            echo "âš ï¸ Auth API returned HTTP $response"
          fi

      - name: Deployment Summary
        run: |
          echo "ðŸš€ Deployment completed successfully!"
          echo "ðŸ“¦ Container image: ${{ env.LAMBDA_IMAGE_URI }}"
          echo "ðŸ“ API URL: https://dev.petertconti.com/api"
          echo "ðŸ± Cats endpoint: https://dev.petertconti.com/api/cats"
          echo "ðŸ” Auth endpoint: https://dev.petertconti.com/api/auth"
          echo "âœ… All infrastructure managed by Terraform with container deployment!"