name: Deploy to Dev

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_bootstrap_check:
        description: 'Skip bootstrap verification (use with caution)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '22'
  TERRAFORM_VERSION: '1.6.0'
  ECR_REPOSITORY: portfolio-pconti-strapi

concurrency:
  group: deploy-dev-${{ github.ref }}
  cancel-in-progress: false

jobs:
  ##############################################################################
  # Verify Bootstrap Resources
  ##############################################################################
  verify-bootstrap:
    name: Verify Bootstrap
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_bootstrap_check != 'true' }}
    permissions:
      id-token: write
      contents: read
    outputs:
      ecr_repository_url: ${{ steps.verify.outputs.ecr_repository_url }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify bootstrap resources exist
        id: verify
        run: |
          set -euo pipefail

          echo "Verifying bootstrap resources..."

          # Check S3 state bucket
          if ! aws s3api head-bucket --bucket portfolio-pconti-tfstate 2>/dev/null; then
            echo "::error::Terraform state bucket 'portfolio-pconti-tfstate' not found. Run bootstrap first."
            exit 1
          fi
          echo "S3 state bucket: OK"

          # Check DynamoDB lock table
          if ! aws dynamodb describe-table --table-name portfolio-pconti-tf-lock >/dev/null 2>&1; then
            echo "::error::DynamoDB lock table 'portfolio-pconti-tf-lock' not found. Run bootstrap first."
            exit 1
          fi
          echo "DynamoDB lock table: OK"

          # Check ECR repository
          ECR_URL=$(aws ecr describe-repositories \
            --repository-names ${{ env.ECR_REPOSITORY }} \
            --query 'repositories[0].repositoryUri' \
            --output text 2>/dev/null || echo "")

          if [ -z "$ECR_URL" ] || [ "$ECR_URL" == "None" ]; then
            echo "::error::ECR repository '${{ env.ECR_REPOSITORY }}' not found. Run bootstrap first."
            exit 1
          fi
          echo "ECR repository: OK ($ECR_URL)"

          echo "ecr_repository_url=$ECR_URL" >> "$GITHUB_OUTPUT"
          echo "All bootstrap resources verified successfully"

  ##############################################################################
  # Build Backend (Strapi)
  ##############################################################################
  build-backend:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: [verify-bootstrap]
    if: ${{ always() && (needs.verify-bootstrap.result == 'success' || needs.verify-bootstrap.result == 'skipped') }}
    permissions:
      id-token: write
      contents: read
    outputs:
      image_uri: ${{ steps.build-push.outputs.image_uri }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build-push
        working-directory: ./backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail

          IMAGE_URI="${ECR_REGISTRY}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"

          echo "Building Strapi image for linux/amd64..."
          docker buildx build \
            --platform linux/amd64 \
            --provenance=false \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            -t "${IMAGE_URI}" \
            -t "${ECR_REGISTRY}/${{ env.ECR_REPOSITORY }}:latest" \
            --push \
            .

          echo "image_uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          echo "Image pushed: ${IMAGE_URI}"

  ##############################################################################
  # Build Frontend (Next.js with OpenNext)
  ##############################################################################
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: [verify-bootstrap]
    if: ${{ always() && (needs.verify-bootstrap.result == 'success' || needs.verify-bootstrap.result == 'skipped') }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          # OpenNext officially supports Node 18/20; stick to 20.x for builds
          node-version: 20
          cache: 'pnpm'
          cache-dependency-path: 'frontend/pnpm-lock.yaml'

      - name: Install dependencies
        working-directory: ./frontend
        run: pnpm install --frozen-lockfile

      - name: Build Next.js with OpenNext
        working-directory: ./frontend
        run: |
          set -euo pipefail

          echo "Building Next.js application..."
          pnpm build

          echo "Building OpenNext package for AWS Lambda..."
          pnpm dlx @opennextjs/aws build

          echo "OpenNext build complete"
          ls -la .open-next/
          test -d .open-next || { echo "::error::.open-next directory missing after build"; exit 1; }

      - name: Upload OpenNext build artifact
        uses: actions/upload-artifact@v4
        with:
          name: opennext-build
          path: frontend/.open-next/**
          if-no-files-found: error
          retention-days: 1

  ##############################################################################
  # Deploy Infrastructure (Terraform)
  ##############################################################################
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    permissions:
      id-token: write
      contents: read
    outputs:
      frontend_url: ${{ steps.outputs.outputs.frontend_url }}
      api_url: ${{ steps.outputs.outputs.api_url }}
      cloudfront_distribution_id: ${{ steps.outputs.outputs.cloudfront_distribution_id }}
      ecs_cluster: ${{ steps.outputs.outputs.ecs_cluster }}
      ecs_service: ${{ steps.outputs.outputs.ecs_service }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download OpenNext build artifact
        uses: actions/download-artifact@v4
        with:
          name: opennext-build
          path: frontend/.open-next

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Create terraform.tfvars
        working-directory: ./infra
        run: |
          set -euo pipefail

          # Decode tfvars from base64 secret
          printf '%s' "${{ secrets.TFVARS_CONTENT_DEV_B64 }}" | base64 -d > terraform.tfvars

          # Normalize line endings
          tr -d '\r' < terraform.tfvars > tf.tmp && mv tf.tmp terraform.tfvars

          # Append/override the strapi_image variable
          echo "" >> terraform.tfvars
          echo "strapi_image = \"${{ needs.build-backend.outputs.image_uri }}\"" >> terraform.tfvars

          echo "terraform.tfvars created ($(wc -l < terraform.tfvars) lines)"

      - name: Terraform Init
        working-directory: ./infra
        run: terraform init -input=false

      - name: Terraform Validate
        working-directory: ./infra
        run: terraform validate

      - name: Terraform Plan
        working-directory: ./infra
        run: |
          terraform plan \
            -var-file=terraform.tfvars \
            -out=tfplan \
            -input=false

      - name: Terraform Apply
        working-directory: ./infra
        run: terraform apply -auto-approve -input=false tfplan

      - name: Get Terraform outputs
        id: outputs
        working-directory: ./infra
        run: |
          echo "frontend_url=$(terraform output -raw frontend_url)" >> "$GITHUB_OUTPUT"
          echo "api_url=$(terraform output -raw strapi_url)" >> "$GITHUB_OUTPUT"
          echo "cloudfront_distribution_id=$(terraform output -raw cloudfront_distribution_id)" >> "$GITHUB_OUTPUT"
          echo "ecs_cluster=$(terraform output -raw ecs_cluster_name)" >> "$GITHUB_OUTPUT"
          echo "ecs_service=$(terraform output -raw ecs_service_name)" >> "$GITHUB_OUTPUT"

  ##############################################################################
  # Wait for ECS Service Stability
  ##############################################################################
  wait-for-ecs:
    name: Wait for ECS Deployment
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for ECS service stability
        run: |
          set -euo pipefail

          echo "Waiting for ECS service to stabilize..."

          aws ecs wait services-stable \
            --cluster "${{ needs.deploy-infrastructure.outputs.ecs_cluster }}" \
            --services "${{ needs.deploy-infrastructure.outputs.ecs_service }}" \
            --region ${{ env.AWS_REGION }}

          echo "ECS service is stable"

  ##############################################################################
  # Invalidate CloudFront Cache
  ##############################################################################
  invalidate-cache:
    name: Invalidate CloudFront
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, wait-for-ecs]
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Invalidate CloudFront cache
        run: |
          set -euo pipefail

          DISTRIBUTION_ID="${{ needs.deploy-infrastructure.outputs.cloudfront_distribution_id }}"

          if [ -n "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "None" ]; then
            echo "Invalidating CloudFront distribution: $DISTRIBUTION_ID"

            INVALIDATION_ID=$(aws cloudfront create-invalidation \
              --distribution-id "$DISTRIBUTION_ID" \
              --paths "/*" \
              --query 'Invalidation.Id' \
              --output text)

            echo "Invalidation created: $INVALIDATION_ID"
          else
            echo "No CloudFront distribution ID found, skipping invalidation"
          fi

  ##############################################################################
  # Health Checks
  ##############################################################################
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, wait-for-ecs, invalidate-cache]

    steps:
      - name: Wait for propagation
        run: sleep 30

      - name: Check frontend health
        run: |
          set -euo pipefail

          FRONTEND_URL="${{ needs.deploy-infrastructure.outputs.frontend_url }}"
          echo "Testing frontend: $FRONTEND_URL"

          for i in {1..5}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$FRONTEND_URL" || echo "000")

            if [ "$HTTP_CODE" -eq 200 ]; then
              echo "Frontend health check passed (HTTP $HTTP_CODE)"
              break
            fi

            echo "Attempt $i: HTTP $HTTP_CODE, retrying in 10s..."
            sleep 10
          done

          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "::warning::Frontend returned HTTP $HTTP_CODE"
          fi

      - name: Check API health
        run: |
          set -euo pipefail

          API_URL="${{ needs.deploy-infrastructure.outputs.api_url }}"
          HEALTH_URL="${API_URL}/_health"
          echo "Testing API health: $HEALTH_URL"

          for i in {1..5}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$HEALTH_URL" || echo "000")

            if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 204 ]; then
              echo "API health check passed (HTTP $HTTP_CODE)"
              break
            fi

            echo "Attempt $i: HTTP $HTTP_CODE, retrying in 10s..."
            sleep 10
          done

          if [ "$HTTP_CODE" -ne 200 ] && [ "$HTTP_CODE" -ne 204 ]; then
            echo "::warning::API health check returned HTTP $HTTP_CODE"
          fi

  ##############################################################################
  # Deployment Summary
  ##############################################################################
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-backend, deploy-infrastructure, health-check]
    if: always()

    steps:
      - name: Print deployment summary
        run: |
          echo "=============================================="
          echo "         DEPLOYMENT SUMMARY"
          echo "=============================================="
          echo ""
          echo "Commit:     ${{ github.sha }}"
          echo "Branch:     ${{ github.ref_name }}"
          echo "Actor:      ${{ github.actor }}"
          echo ""
          echo "Frontend:   ${{ needs.deploy-infrastructure.outputs.frontend_url }}"
          echo "API:        ${{ needs.deploy-infrastructure.outputs.api_url }}"
          echo "Container:  ${{ needs.build-backend.outputs.image_uri }}"
          echo ""
          echo "=============================================="
